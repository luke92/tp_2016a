#+TITLE: TP2: Clases genéricas y polimorfismo
#+LANGUAGE: es
#+OPTIONS: html-postamble:nil
#+OPTIONS: ^:nil toc:nil H:3 num:2 timestamp:nil
#+HTML_DOCTYPE: html5
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/org.css">
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/org-solarized.css">
#+LINK: src https://github.com/ungs-prog2/tp_2016a/tree/gh-pages/TP2/src/%s
#+LINK: gh https://github.com/ungs-prog2/tp_2016a

La fecha de entrega de este TP es el *16 de junio de 2016*. Se puede realizar de
manera individual, o en grupos de a lo sumo dos personas.

El TP consta de dos partes, que se entregarán de manera conjunta en un único
ZIP con el código Java, respetando la estructura del proyecto de Eclipse que se
proporciona como parte de la consigna.

El proyecto de Eclipse se puede descargar desde [[gh:/releases][esta página]].

  - *IMPORTANTE*: la configuración del proyecto incluye varios lineamientos,
    incluyendo la guía de estilo a seguir.

    Se debe, por tanto, /importar/ el proyecto proporcionado, y no meramente
    copiar los archivos de código.

A modo informativo, se detallan los objetivos del TP en el [[#objetivos]].

#+TOC: headlines 1


* Parte 1: Estructuras de datos genéricas
:PROPERTIES:
:UNNUMBERED: t
:CUSTOM_ID: parte1
:END:

En esta parte se pide la implementación de las siguientes tres clases:

  1. /DiccConjunto:/ un diccionario sobre /Conjunto/.

  2. /ABB:/ un árbol de búsqueda sobre la clase abstracta /ArbolBinario/.

  3. /TuplaDic:/ puente entre /Conjunto/ y /DiccConjunto/.

Para ayudar con la implementación, se incluyen algunas clases de soporte.

#+TOC: headlines 2 local

** Clases ya implementadas

Como base para la implementación, la consigna incluye la definición de las
siguientes clases e interfaces:

  - interfaz /Diccionario/
  - clase /Conjunto/
  - clase /ArbolBinario/ (abstracta)

*** La interfaz /Diccionario/
:PROPERTIES:
:CUSTOM_ID: diccionario
:END:

La interfaz pública /Diccionario/ define cinco operaciones con dos tipos
paramétricos (la clave /K/ y el valor /V):/

#+BEGIN_SRC java
public interface Diccionario<K, V>
{
    void guardar(K clave, V valor);

    V obtener(K clave);

    boolean pertenece(K clave);

    void eliminar(K clave);

    int tamaño();
}
#+END_SRC

La documentación de cada método se incluye en el archivo [[src:parte1/Diccionario.java][Diccionario.java]].

No se permite realizar ningún cambio a esta interfaz.


*** La clase /Conjunto/
:PROPERTIES:
:CUSTOM_ID: conjunto
:END:

Se incluye la implementación de un /Conjunto/ genérico con el tipo paramétrico /T/
(el tipo del elemento):

#+BEGIN_SRC java
class Conjunto<T extends Comparable<T>>
{
    void agregar(T elem) { ... }

    boolean pertenece(T elem) { ... }

    void quitar(T elem) { ... }

    T recuperar(T elem) { ... }
}
#+END_SRC

De la definición de la clase se deduce que los elementos del conjunto deben ser
*comparables entre sí*.

La documentación de cada método se incluye en el archivo [[src:parte1/Conjunto.java][Conjunto.java]].

Se proporciona la implementación completa de la clase. No se pueden realizar
alteraciones, ni agregar métodos adicionales. En particular, nótese que, de
manera intencional, este Conjunto no proporciona el método /tamaño()/.


*** La clase abstracta /ArbolBinario/
:PROPERTIES:
:CUSTOM_ID: arbol-binario
:END:

La clase abstracta /ArbolBinario/ define un árbol binario genérico que delega a
las clases hijas (concretas) las operaciones de inserción, búsqueda y borrado.

La delegación se realiza mediante sobrecarga. Por ejemplo, para la búsqueda:

#+BEGIN_SRC java
abstract class ArbolBinario<K, V> implements Diccionario<K, V>
{
    private Nodo raiz;

    //
    // Métodos implementados por ArbolBinarioB.
    //
    @Override
    public V obtener(K k) {
        return obtener(raiz, k);
    }

    @Override
    public boolean pertenece(K k) {
        return pertenece(raiz, k);
    }

    //
    // Métodos sobrecargados que implementarán las clases hijas.
    //
    protected abstract V obtener(Nodo padre, K k);

    protected abstract boolean pertenece(Nodo padre, K k);
}
#+END_SRC

Como se puede observar también, la clase /ArbolBinario/ implementa directamente
la interfaz /Diccionario/, por lo que tiene los mismos dos tipos paramétricos que
este.


** Clases a implementar

*** /DiccConjunto/ y /TuplaDic/
:PROPERTIES:
:CUSTOM_ID: dicc-conjunto
:END:

La clase /DiccConjunto/ debe implementar la interfaz /[[#diccionario][Diccionario]]/ sobre el TAD
/Conjunto/.

Como el número de tipos paramétricos difiere entre estas dos clases, será
necesario usar un TAD intermedio que actúe como puente entre /Conjunto<T>/ y
/DiccConjunto<K, V>/.

Se recomienda usar /TuplaDic<K, V>/ como TAD intermedio. Es una tupla de dos
elementos en la que la comparación se realiza solamente por el primero de ellos
(en este caso la clave).

Importante: para que funcione, el /compareTo()/ de la tupla debe ser consistente
con /equals()/.

Archivos a completar:

  - [[src:parte1/TuplaDic.java][TuplaDic.java]]: implementar =toString()=, =equals()= y =compareTo()=.

  - [[src:parte1/DiccConjunto.java][DiccConjunto.java]]: implementar =guardar()=, =obtener()=, =pertenece()= =tamaño()= y
    =eliminar()=.

*** /ABB/
:PROPERTIES:
:CUSTOM_ID: abb
:END:

La clase /ABB/ implementa un árbol de búsqueda binario heredando de la clase
abstracta /ArbolBinario/. Esto significa que:

  - /ABB/ solo necesita implementar los cuatro métodos “abstract” de
    /ArbolBinario:/ =guardar()=, =obtener()=, =pertenece()= y =eliminar()=.

  - como /ArbolBinario/ ya implementa la interfaz /Diccionario/, no se necesita
    código especial para que /ABB/ la implemente.

  - los métodos que funcionarían para cualquier árbole binario (no solo de
    búsqueda) se pueden implementar en la clase base. Por ejemplo, /ArbolBinario/
    ya implementa =tamaño()=, y no es necesario sobreescribirlo.

A su vez, en este caso la clase base acota bastante cómo debe ser la
implementación de la clase hija. En particular:

  - el diseño de la recursión lo define /ArbolBinario:/ en lugar de usar métodos
    en /Nodo/, llama a métodos sobrecargados de la clase hija con la raíz como
    argumento (como se mostró en la [[#arbol-binario][sección anterior]]).

  - las clases hijas pueden acceder a los campos de /Nodo/, pero no tienen acceso
    a “re-escribir” la raíz del árbol (=ArbolBinario.raiz= es /private/).

  - lo que espera la clase base es que los métodos sobrecargados /devuelvan/ la
    nueva raíz, que será la original de no haberse producido cambios. Por
    ejemplo, para el borrado:

    #+BEGIN_SRC java
    abstract class ArbolBinario<K, V>
    {
        public void guardar(K clave, V valor) {
            // Se sobreescribe la raíz con lo que devuelva la clase hija.
            // Si, por ejemplo, el árbol estaba vacío, la clase hija devuelve
            // directamente el nodo nuevo.
            raiz = guardar(raiz, new Nodo(clave, valor));
        }

        public void eliminar(K clave) {
            // Se sobreescribe la raíz con lo que devuelva la clase hija.
            // Si, por ejemplo, solo existe la raíz y hay que borrarla, la
            // clase hija devolvería "null".
            raiz = eliminar(raiz, clave);
        }
    }

    public class ABB<K, V> extends ArbolBinario<K, V>
    {
        protected Nodo guardar(Nodo p, Nodo nuevo) {
            if (p == null) {
                // La raíz es null o hemos llegado a una hoja.
                // En este punto se inserta el nodo, devolviéndolo.
                return nuevo;
            }

            // Seguir buscando
            // ...
        }

        protected Nodo eliminar(Nodo p, K clave) {
            if (p == null) {
                // La raíz es null o hemos llegado a una hoja.
                // No hay nada que borrar y se devuelve null.
                return null;
            }
            else if (/* p.clave == clave */) {

                // Si solo hay un hijo, devolver ese hijo.
                if (p.izq == null)
                    return p.der;
                else if (p.der == null)
                    return p.izq;

                // Caso difícil: el nodo tiene dos hijos.
                // ...
            }
            else
                // Seguir buscando
                // ...
    }
    #+END_SRC

** Pruebas automáticas

Se incluye, en el paquete =parte1.pruebas=, una serie de pruebas automáticas con
las que ambas implementaciones de /Diccionario/ deben cumplir.

* Parte 2: Polimorfismo y desacoplamiento
:PROPERTIES:
:UNNUMBERED: t
:CUSTOM_ID: parte2
:END:

En esta segunda parte se pide la refactorización de una clase haciendo uso de
polimorfismo como mecanismo para desacoplar componentes.

En otras palabras: se tiene una clase con un único método, demasiado largo, que
se desea descomponer en módulos distintos (clases), cada uno de las cuales se
encargue de una pequeña parte de la tarea global.

La clase se llama =BDExport=, y guarda una lista de objetos en un archivo. Se
proporciona una clase [[src:parte2/Main.java][Main]] que muestra su uso:

#+BEGIN_SRC java
public static void main(String[] args) {
    BDExport.export("clientes.csv", Formato.CSV, listaClientes());
    BDExport.export("empleados.json", Formato.JSON, listaEmpleados());
}
#+END_SRC

Y esta es la documentación y la firma del método =export()=, tal y como aparece
en [[src:parte2/BDExport.java][BDExport.java]]:

#+BEGIN_SRC java
/**
 ,* Exporta una serie de objetos de la base de datos a un archivo.
 ,*
 ,* Recibe el nombre del archivo, el formato deseado (CSV o JSON), y
 ,* la lista de objetos (Empeados o Clientes).
 ,*/
public static void export(String archivo, Formato formato, List<?> objetos) {
    // 70 líneas de código ...
    //
    // Abrir archivo
    // Determinar el tipo del objeto (!)
    // Extraer los atributos según la clase a exportar (!)
    // Exportar a CSV o JSON, con varios switch/if/else combinados (!)
    // Capturar excepciones e imprimir a System.err (!)
}
#+END_SRC

A lo que se quiere llegar es a un código más elegante y extensible que permita,
en el futuro, agregar nuevos formatos y tipos de objetos sin tener que
reescribirlo entero.

*Nota*: el diseño de la la solución es libre, pero a continuación se detalla un
posible diseño. El alumno puede decidir seguirlo en su totalidad, o en parte, o
implementar uno propio desde cero.

** Sugerencia de diseño

Se sugiere el uso de una clase abstracta /FormatWriter/ y una interfaz /Exportable/
tal que el código de =export()= quede como sigue:

#+BEGIN_SRC java
public static void export(FormatWriter exporter, Iterable<? extends Exportable> objetos) {
    Atributos attrs = new Atributos();
    for (Exportable e : objetos) {
        attrs.clear();
        e.saveAtributos(attrs);
        exporter.guardar(attrs);
    }
}
#+END_SRC

Y la función =main()=:

#+BEGIN_SRC java
public static void main(String[] args) {
    try (FormatWriter csv = new CSV("clientes.csv");
         FormatWriter json = new JSON("empleados.json")) {
        BDExport.export(csv, listaClientes());
        BDExport.export(json, listaEmpleados());
    } catch (IOException e) {
        System.err.println("No se pudo realizar la copia de seguridad");
    }
}
#+END_SRC

*** La interfaz /Exportable/

En lugar de dejar que /BDExport/ “averigüe” el tipo de cada objeto a exportar, y
extraiga sus atributos con un cast, los propios objetos deberían saber
exportarse a sí mismos.

Esto lo pueden conseguir mediante la interfaz sugerida /Exportable:/

#+BEGIN_SRC java
public interface Exportable
{
    /**
     ,* Guarda los atributos de la instancia en un diccionario.
     ,*
     ,* En esta versión simplificada, los valores siempre son
     ,* strings (ver clase Atributos).
     ,*/
    void saveAtributos(Atributos attrs);
}
#+END_SRC

Así, se deberían modificar las clases [[src:parte2/Cliente.java][Cliente]] y [[src:parte2/Empleado.java][Empleado]] para que implementen
esta interfaz.

*** La clase /FormatWriter/ y sus subclases

La clase abstracta /FormatWriter/ abstrae el concepto de serializar, en cualquier
formato, los atributos de un objeto:

#+BEGIN_SRC java
public abstract class FormatWriter
{
    public abstract void guardar(Atributos attrs);
}
#+END_SRC



* Apéndice A: Resumen de objetivos
:PROPERTIES:
:UNNUMBERED: t
:CUSTOM_ID: objetivos
:END:

** Parte 1

  1. El uso de interfaces como definición completa de un tipo abstracto de
     datos.

     - En nuestro caso, el TAD-interfaz [[#diccionario][Diccionario]].

  2. La implementación de un mismo TAD-interfaz por dos clases no relacionadas
     por herencia.

     - En nuestro caso, las clases [[#abb][ABB]] y [[#dicc-conjunto][DiccConjunto]].

  3. La implementación de un TAD sobre otro TAD, resolviendo cualquier
     impedancia entre ellos.

     - En nuestro caso, /DiccConjunto<K, V>/ sobre [[#conjunto][Conjunto<T>]], con la ayuda de
       [[#dicc-conjunto][TuplaDic]].

  4. El uso de clases abstractas para diseñar las clases hijas.

     - En nuestro caso, la clase /ArbolBinario/ define la clase /Nodo/ y mantiene
       controlado (privado) el acceso a la raíz. Acota a cuatro métodos lo que
       las clases derivadas deben implementar.

  5. El uso de clases internas para evitar parametrizar clases auxiliares, y el
     uso de visibilidad “default” para evitar la proliferación de getters y setters.

     - En nuestro caso, no es necesario que la clase interna /ArbolBinario.Nodo/
       sea paramétrica, pues queda instanciada con /K/ y /V/. Además, al ser
       /protected/ pero tener sus variables visibilidad default, /clave/ y /valor/ no
       quedan expuestos a otras clases, pero no son necesario getters/setters.
